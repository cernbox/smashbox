#!/usr/bin/python
import sys,os,socket
import subprocess,time,signal
from multiprocessing import Process

class SmashboxCLI:
    def __init__(self,config):
        self.SMASHBOX_CMD_BASIC = ["smash","--keep-going"]
        for i in range(0, len(config)):
            self.SMASHBOX_CMD_BASIC += ["-o",config[i]]
    def start(self,sync_engine,testset,test_name,runid): 
        parentdir = os.path.dirname(os.path.realpath(__file__))    
        SMASHBOX_CMD = self.SMASHBOX_CMD_BASIC[:]
        for j in range(0, len(sync_engine)):
            SMASHBOX_CMD += ["-o",sync_engine[j]]
        if (testset == "all"):
            SMASHBOX_CMD += ["-a"]
        else:
            SMASHBOX_CMD += ["-t",str(testset)] 
        SMASHBOX_CMD += ["-o","runid=%s"%runid,"lib/%s"%test_name] 
        process = subprocess.Popen(SMASHBOX_CMD,stdout=subprocess.PIPE, stderr=subprocess.STDOUT, preexec_fn=os.setsid, cwd=parentdir)
        pid = str(os.getpgid(process.pid))
        p = Process(target=timeout, args=(pid,))
        p.start()
        while True:
            line = process.stdout.readline()
            print line,
            if line == '' and process.poll() != None:
                p.terminate()
                p.join()
                break         

def timeout(pid):
    print pid
    TIMEOUT = 1800
    start = time.time()
    while True:
        if int(time.time() - start) > TIMEOUT:
            stop_execution(pid)
            break

def stop_execution(pid):
    pid = int(pid)
    print ("killing %s: ok"%pid)
    try:
        os.killpg(pid, signal.SIGTERM)
        time.sleep(2)
        try:
            os.killpg(pid, signal.SIGKILL)
        except:
            pass
        time.sleep(2)
    except Exception, e:
        print (e)
  
def get_config(path):
    import io    
    path = os.path.abspath(path)    
    if (os.path.exists(path)):
        with io.open(path,'r') as file:
            data = eval(file.read())
        return data 
    else:
        print "path does not exists %s"%path
        sys.exit()
        
def check_smashbox_basic_conf():
    if not (os.path.exists('../etc/smashbox.conf')):
        subprocess.call(["cp",'../etc/smashbox.conf.template','../etc/smashbox.conf'],cwd=os.path.dirname(os.path.realpath(__file__)))

def run(testset_config): 
    client = SmashboxCLI(testset_config["config"])
    sync_engines = testset_config["sync_engines"]
    tests = testset_config["tests"]
    for k in range(0, int(testset_config["loop"])):
        for j in range(0, len(tests)):
            for i in range(0, len(sync_engines)):
                test_name = tests[j]["test_name"]
                testset = tests[j]["testset"]
                runid = tests[j]["runid"]
                client.start(sync_engines[i],testset,test_name,runid)     
                   
    return (testset_config.has_key("reboot") and testset_config["reboot"] == True)
          
def main(arguments):
    check_smashbox_basic_conf()
    for arg_i in range(1, len(arguments)):
        testset_config = get_config(arguments[arg_i])
        return run(testset_config)            
		
def get_lock():
	process_name = 'running_test'		
	global lock_socket   # Without this our lock gets garbage collected
	lock_socket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
	try:
		lock_socket.bind('\0' + process_name)
		return 1
	except socket.error:
		return 0
        
if __name__ == '__main__':
    """    """
    arguments = sys.argv
    if (get_lock()==1):
        if (main(arguments)==True):
            print "rebooting now.."
    else:
        print ("Aborting - wait for the end of the previous smashbox run")
        sys.exit()




