import logging
import os.path
from pathlib import Path
from typing import List, Sequence, Tuple

import smashbox.compatibility.argparse as argparse
from smashbox.config import load_config, log_config, get_logger, Configuration


main_config_file = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
    "etc",
    "smashbox.conf.yaml",
)


def keyval_tuple(x: str) -> Tuple[str, str]:
    a, b = x.split("=", 1)
    return (a.strip(), b)


def arg_parser(**kwds):
    """Create an ArgumentParser with common options for smash scripts and tools."""

    parser = argparse.ArgumentParser(**kwds)

    parser.add_argument(
        "--option",
        "-o",
        metavar="key=val",
        dest="options",
        type=keyval_tuple,
        action="append",
        help="set config option",
    )
    parser.add_argument(
        "--dry-run",
        "-n",
        action="store_true",
        help="show config options and print what tests would be run",
    )
    parser.add_argument(
        "--quiet",
        "-q",
        action="store_true",
        help="do not produce output (other than errors)",
    )
    parser.add_argument(
        "--verbose", "-v", action="store_true", help="produce more output"
    )
    parser.add_argument(
        "--debug", action="store_true", help="produce very verbose output"
    )
    parser.add_argument(
        "--config",
        "-c",
        dest="configs",
        default=[],
        action="append",
        help="config files (one or more), added on to of default config file",
    )
    return parser


def configure(
    cmdline_opts: Sequence[Tuple[str, str]],
    config_files: List[Path | str] | None = None,
) -> Configuration:
    """Initialize config object and return it.
    First read the sequence of config_files (including the
    main_config_file). All symbols defined by these files will be set
    as attributes of the config object.
    Then process cmdline_opts (which is a list of tuples generated by
    arg_parser). If attribute matching the option already exists (was
    defined in a configuration file) then eval to the same type (if not
    None). Otherwise leave string values. The string "None" is special
    and it is always converted to None and may always be assigned.
    """
    logger = get_logger()
    config = load_config(main_config_file)
    if config_files is None:
        config_files = []

    config_files = [main_config_file] + config_files

    # for cf in config_files:
    #    execfile(cf, {}, config.__dict__)

    if cmdline_opts:
        for key, val in cmdline_opts:
            try:
                if val == "None":
                    val = None
                else:
                    attr = getattr(config, key)
                    # coerce val type to attr's type unless attr is set to None (then leave as-is <string>)
                    try:
                        if attr is not None:
                            val = type(attr)(val)
                    except ValueError as x:
                        # allow setting to None
                        logger.warning(
                            "cannot set option (type mismatch) %s=%s --> %s",
                            key,
                            repr(val),
                            x,
                        )
                        continue
            except AttributeError:
                # if attr unknown then leave the val as-is (string)
                pass

            setattr(config, key, val)

    log_config(config, level=logging.DEBUG)

    return config