#!/usr/bin/python
import sys,os, subprocess
import matplotlib.pyplot as plt
from influxdb import InfluxDBClient
import numpy as np
from gi.overrides.keysyms import upleftcorner
import matplotlib.mlab as mlab

def get_config(path):
    import io    
    path = os.path.abspath(path)    
    if (os.path.exists(path)):
        with io.open(path,'r') as file:
            data = eval(file.read())
        return data 
    else:
        print "path does not exists %s"%path
        sys.exit()
        

def get_low_high(avg,values):
    standard = True
    if standard==False:        
        low, high = [], []
        for value in values:
            if value>avg:
                high.append(value)
            else:
                low.append(value) 
        return np.std(low),np.std(high)  
    else:
        return np.std(values),np.std(values) 
             
def get_hour_from_timestamp(time):
    start = time.find('T') + 1
    end = time.find(':', start)
    return int(time[start:end])

def compare_monit_histsync_graph(results,runid):
    fig = plt.figure() 
    ax = fig.add_subplot(111)
    avg_total = []
    values = []
    xTickMarks = []
    xTickGraph = []
    global_max = []
    for key, objs in results.items() :
        tmp_values = []
        for obj in objs:
            tmp_values.append(obj["value"])
        size = len(tmp_values)  
        tmp_values = np.array(tmp_values) 
        global_max.append(np.max(tmp_values))
        values.append(tmp_values)
        
        xTickMarks.append(key)
    
    global_max= (np.max(global_max))   
    ax.set_xlim(left=0)
    ax.set_xlim(right=global_max)
    ind = np.arange(len(xTickMarks))                # the x locations for the groups
    width = 1                      # the width of the bars
    
    # the histogram of the data
    for value in values:
        n, bins, patches = ax.hist(values, bins=100, normed=True, histtype='step', range=(0,global_max))
        xTickGraph.append(patches[0])
    
    ax.set_xlabel('Synchronisation time [s]')
    ax.set_ylabel('Probability')
    ax.legend(xTickGraph,xTickMarks)
    plt.title('Monitoring - Histogram\nMachine: %s'%(runid))
    plt.grid(True)
    plt.tight_layout()
    plt.draw()
    
def compare_monit_cm_histsync_graph(results,runid):
    fig = plt.figure() 
    ax = fig.add_subplot(111)
    avg_total = []
    values = []
    xTickMarks = []
    xTickGraph = []
    global_max = []
    for key, objs in results.items() :
        tmp_values = []
        for obj in objs:
            tmp_values.append(obj["value"])
        size = len(tmp_values)  
        tmp_values = np.array(tmp_values) 
        global_max.append(np.max(tmp_values))
        values.append(tmp_values)
        
        xTickMarks.append(key)
    
    global_max= (np.max(global_max))   
    ax.set_xlim(left=0)
    ax.set_xlim(right=global_max)
    ind = np.arange(len(xTickMarks))                # the x locations for the groups
    width = 1                      # the width of the bars
    
    # the histogram of the data
    for value in values:
        n, bins, patches = ax.hist(value, bins=100, normed=True, cumulative=True, histtype='step', range=(0,global_max))
        xTickGraph.append(patches[0])
    
    ax.set_xlabel('Synchronisation time [s]')
    ax.set_ylabel('Probability')
    ax.legend(xTickGraph,xTickMarks)
    plt.title('Monitoring - Histogram\nMachine: %s'%(runid))
    plt.grid(True)
    plt.tight_layout()
    plt.draw()    
def compare_monit_time_graph(results,runid):
    fig = plt.figure() 
    ax = fig.add_subplot(111)
    xTickMarks = range(0,24)
    avg_total = []
    error_total_low = []
    error_total_high = []
    values = []
    for i in range(0,24):
        avg_total.append([]) 
        error_total_low.append([]) 
        error_total_high.append([]) 
        values.append([])
        
    for key, objs in results.items() :
        for obj in objs:
            hour = get_hour_from_timestamp(obj["time"])
            values[hour].append(obj["value"])
    
    for i in range(0,24): 
        avg = np.mean(np.array(values[i])) 
        low, high = get_low_high(avg,values[i])   
        avg_total[i].append(avg)   
        error_total_low[i].append(low)
        error_total_high[i].append(high)
    ## necessary variables
    ind = np.arange(len(xTickMarks))                # the x locations for the groups
    width = 1                      # the width of the bars
    # axes and labels
    for i in range(0,24):
        ax.bar(ind[i], avg_total[i], width, color='b',
                yerr=[error_total_low[i],error_total_high[i]],
                error_kw=dict(capsize=5, elinewidth=2,ecolor='black'))
    ax.set_xlim(0,len(ind))
    ax.set_ylim(bottom=0)
    ax.set_ylabel('Synchronisation Time (s)')     
    ax.set_xticks(ind)
    xtickNames = ax.set_xticklabels(xTickMarks)
    plt.setp(xtickNames, rotation=45, fontsize=10)
    plt.title('Monitoring - %s\nDistributions of synchronisation times during the day\nMachine: %s'%(key,runid))
    plt.tight_layout()
    plt.draw()
    
def compare_monit_sync_graph(results,runid):
    fig = plt.figure() 
    ax = fig.add_subplot(111)
    xTickMarks = []
    avg_total = []
    error_total_low = []
    error_total_high = []
    avg_upl = []
    error_upl_low = []
    error_upl_high = []
    avg_dwl = []
    error_dwl_low = []
    error_dwl_high = []
    for key, objs in results.items() :
        values = []
        for obj in objs[0]:
            values.append(obj["value"])
        values = np.array(values)
        avg = np.mean(values)
        low, high = get_low_high(avg,values)     
        avg_total.append(avg)   
        error_total_low.append(low)  
        error_total_high.append(high) 
        
        values = []
        for obj in objs[1]:
            values.append(obj["value"])
        values = np.array(values)
        avg = np.mean(values)
        low, high = get_low_high(avg,values)     
        avg_upl.append(avg)   
        error_upl_low.append(low)
        error_upl_high.append(high) 
        
        values = []
        for obj in objs[2]:
            values.append(obj["value"])
        values = np.array(values)
        avg = np.mean(values)
        get_low_high(avg,values)
        low, high = get_low_high(avg,values)      
        avg_dwl.append(avg)   
        error_dwl_low.append(low)
        error_dwl_high.append(high) 
        
        xTickMarks.append(key)
    ## necessary variables
    ind = np.arange(len(xTickMarks))                # the x locations for the groups
    width = 0.3                      # the width of the bars
    # axes and labels
    total = ax.bar(ind, avg_total, width, color='b',
                yerr=[error_total_low,error_total_high],
                error_kw=dict(capsize=5, elinewidth=2,ecolor='black'))
    upload = ax.bar(ind+width, avg_upl, width, color='g',
                yerr=[error_upl_low,error_upl_high],
                error_kw=dict(capsize=5, elinewidth=2,ecolor='black'))
    download = ax.bar(ind+2*width, avg_dwl, width, color='y',
                yerr=[error_dwl_low,error_dwl_high],
                error_kw=dict(capsize=5, elinewidth=2,ecolor='black'))
    ax.set_xlim(-0.1,len(ind))
    ax.set_ylim(bottom=0)
    ax.set_ylabel('Synchronisation Time (s)')     
    ax.set_xticks(ind+0.45)
    xtickNames = ax.set_xticklabels(xTickMarks)
    plt.setp(xtickNames, rotation=45, fontsize=10)
    plt.title('Monitoring - distributions of synchronisation times\nMachine: %s'%(runid))
    ## add a legend
    ax.legend((total[0], upload[0], download[0]), ('Total', 'Upload', 'Download'))
    plt.tight_layout()
    plt.draw()

def run(testset_config): 
    config = testset_config["config"]
    client = InfluxDBClient(config["remote_storage_server"], 8086, config["remote_storage_user"], config["remote_storage_password"], config["remote_database"])
    
    tests = testset_config["tests"] 
    for test in tests:
        if test["test_name"]=="monit":
            for type in test["graph"]:
                if type["show"]==True and type["type"]=="compare-sync":
                    points = {}
                    for server in type["server"]:
                        tot = client.query("SELECT value FROM \"%s-%s\" WHERE runid='%s' and server_name='%s'"%(test["test_name"],"total-syn",type["runid"],server))
                        upl = client.query("SELECT value FROM \"%s-%s\" WHERE runid='%s' and server_name='%s' and worker_name='%s'"%(test["test_name"],"syn",type["runid"],server,"worker0"))
                        dwl = client.query("SELECT value FROM \"%s-%s\" WHERE runid='%s' and server_name='%s' and worker_name='%s'"%(test["test_name"],"syn",type["runid"],server,"worker1"))
                        points[server]=[list(tot.get_points()),list(upl.get_points()),list(dwl.get_points())]
                    compare_monit_sync_graph(points,type["runid"])
                if type["show"]==True and type["type"]=="compare-time":
                    points = {}
                    server = type["server"]
                    tot = client.query("SELECT value FROM \"%s-%s\" WHERE runid='%s' and server_name='%s'"%(test["test_name"],"total-syn",type["runid"],server))
                    points[server]=list(tot.get_points())
                    compare_monit_time_graph(points,type["runid"])
                if type["show"]==True and type["type"]=="cm-histogram-sync":
                    points = {}
                    for server in type["server"]:
                        tot = client.query("SELECT value FROM \"%s-%s\" WHERE runid='%s' and server_name='%s'"%(test["test_name"],"total-syn",type["runid"],server))
                        points[server]=list(tot.get_points())
                    compare_monit_cm_histsync_graph(points,type["runid"])
                if type["show"]==True and type["type"]=="histogram-sync":
                    points = {}
                    server = type["server"]
                    tot = client.query("SELECT value FROM \"%s-%s\" WHERE runid='%s' and server_name='%s'"%(test["test_name"],"total-syn",type["runid"],server))
                    points[server]=list(tot.get_points())
                    compare_monit_histsync_graph(points,type["runid"])
    plt.show()                
def main(arguments):
    analyse_path = os.path.join(os.path.dirname(__file__),'analyse.config')
    if len(arguments)==1 and os.path.exists(analyse_path):
        print "takes %s config path"%analyse_path
        arguments.append(analyse_path)
    for arg_i in range(1, len(arguments)):
        testset_config = get_config(arguments[arg_i])
        run(testset_config)            
       
if __name__ == '__main__':
    """    """
    arguments = sys.argv
    main(arguments)




